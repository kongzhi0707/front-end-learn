### 响应性布局方案

响应性布局指的是在同一页面在不同屏幕尺寸下有不同的布局。我们只需要开发一套界面，通过检测视口分辨率，针对不同客户端做代码处理，来展现不同的布局和内容。

#### 一）px 和 视口

在静态网页中，我们经常使用像素(px) 作为单位，来描述一个元素的宽高以及定位信息。在 PC 端，我们认为在 css 中，1px 所表示的真实长度是固定的。那么 px 真的是一个和设备无关，跟长度单位米一样是固定的大小的吗？ 答案是否定的，在网页中我们设置的 font-size 为 16px，在 PC 端下和在移动端下显示的两种不同的结果。字体同样是 16px，在 PC 端中文字正常显示，在移动端文字很小，几乎看不到，说明在 css 中 1px 并不是固定大小。

那么 css 中的 1px 的真实长度到底是由什么决定的呢？为了理清这两个概念我们首先介绍像素和视口的概念。

##### 1. 像素

像素是网页布局的基础，一个像素表示计算机屏幕所能显示的最小区域，像素又分为两种类型：css 像素 和 物理像素。

我们在 js 或者 css 代码中使用的 px 单位是指 css 像素，但是物理像素也叫做设备像素，只与设备或者说硬件有关，同样尺寸的屏幕，设备的密度越高，物理像素也就越多。
下面表示 css 像素和物理像素的 具体区别：

css 像素：为 web 开发者提供，在 css 中是有的一个抽象单位。
物理像素：只与设备的硬件密度有关，任何设备的物理像素都是固定的。

##### 2. 视口

广义的视口，是指浏览器显示内容的屏幕区域，狭义的视口包括布局视口，视觉视口 和 理想视口。

##### 2.1）布局视口 (layout viewport)

布局视口定义了 PC 网页在移动端的默认布局行为。PC 端的分辨率较大，布局视口默认为 980px. 也就是说在不设置网页的 viewport 的情况下，PC 端的网页默认会以布局视口为基准，在移动端进行展示。因此默认布局视口时，PC 端的网页在移动端展示很模糊。

##### 2.2）视觉视口

视觉视口表示浏览器内看到的网站的显示区域，用户可以通过缩放来查看网页的显示内容，从而改变视觉视口。就好像我们拿着一个放大镜分别从不同距离观察同一个物体，视觉视口仅仅类似于放大镜中显示的内容，因此视觉视口不会影响布局视口的宽度和高度。

##### 2.3）理想视口

理想视口 全称为 "理想的布局视口"，在移动设备中是指 设备的分辨率。换句话说，理想视口或说分辨率是给定设备物理像素的情况下，最佳的 "布局视口"。

##### 分辨率 和 物理像素 之间的关系是什么？

```
1 DPR = 物理像素 / 分辨率
```

在不缩放的情况下，一个 css 像素就对应一个 dpr，也就是说，在不缩放的情况下：

```
1 CSS像素 = 物理像素 / 分辨率
```

在移动端的布局中，我们可以通过 viewport 元标签来控制布局，比如一般情况下，我们可以通过下述标签使得移动端在理想视口下的布局：

```
<meta id="viewport" name="viewport" content="width=device-width; initial-scale=1.0; maximum-scale=1; user-scalable=no;">
```

上述 meta 标签的每一个属性的详细介绍如下：

```
width: 定义布局视口的宽度，单位为像素。
height: 定义布局视口的高度，单位为像素。
initial-scale: [0, 10] 初始缩放比例，1表示不缩放。
minimum-scale: [0, 10], 最小缩放比例。
maximum-scale: [0, 10], 最大缩放比例。
user-scalable: yes/no 是否允许手动缩放页面，默认值为yes.
```

在移动端布局中，在 meta 标签中我们会将 width 设置为 device-width，device-width 一般是表示分辨率的宽，通过 width = device-width 的设置我们就将布局视口设置成了理想的视口。

#### 3）px 与 自适应

上面我们了解到了当通过 viewport 元标签，设置布局视口为理想视口时，1 个 css 像素可以表示成:

```
1 CSS像素 = 物理像素 / 分辨率
```

我们知道，在 PC 端的布局视口一般情况下为 980px，移动端以 iphone6 为列，分辨率为 375 _ 667, 也就是说布局视口在理想的情况下为 375px。比如现在我们有一个 750px _ 1134px 的视觉高，那么在 PC 端，一个 css 像素可以如下计算:

```
PC 端计算方式如下:

1 CSS 像素 = 物理像素 / 分辨率 = 750 / 980 = 0.76px
```

```
在 iphone6 下：

1 CSS 像素 = 物理像素 / 分辨率 = 750 / 375 = 2px
```

也就是说在 PC 端，一个 css 像素可以使用 0.76 个物理像素来表示，在 iphone6 中，一个 CSS 像素表示了 2 个物理像素。不同的移动设备的分辨率不同。换句话说 1 个 CSS 像素可以表示的物理像素也是不同的。因此如果在 CSS 中仅仅通过 px 作为长度和宽度的单位，造成的结果就是无法通过一套样式，实现各端的自适应。

#### 二）媒体查询

在前面我们说到，不同端的设备下，在 CSS 中，1px 所表示的物理像素的大小时不同的，因此通过一套样式，是无法实现各端的自适应。因此我们给每套设备各一套不同的样式来实现自适应的效果的。因此我们可以使用 媒体查询 可以针对不同的媒体类型定义不同的样式。特别是响应性页面，可以针对不同屏幕的大小，编写多套方式，从而达到自适应的效果。利用媒体查询根据不同的屏幕设备设置各种屏幕宽度下的根元素的 font-size，然后布局使用 rem 代替 px 为长度单位，从而实现响应式布局。

##### 2.1) 怎么计算出各个尺寸屏幕下的 html 元素 font-size 要设置多少呢？

我们首先要找一下各个屏幕尺寸下的代表机型，然后以其中一个为标准，计算出其他的，一般以 iphone6/7/8 为标准，为什么呢？因为现在的设计稿大多是以 ihone6/7/8 的屏幕宽度 375px 来设置的。

比较小的屏幕：iphone5 屏幕宽度: 320px
标准的屏幕：iphone6/7/8 屏幕宽度: 375px;
比较大的屏幕: iphone6/7/8 plus 的屏幕宽度 414px;
其他更多的比如 ipad 的屏幕：768px;

```
如果将标准的屏幕宽度设置为100px

@media only screen and (min-width: 375px) and (max-width: 413px) {
  html {
    font-size: 100px
  }
}

那么小屏幕的  100 / x = 375 / 320   x = 85.333...
@media only screen and (max-width: 374px) {
  html {
    font-size: 85px
  }
}


那么大屏幕的  100 / x = 375 / 414  x = 110.4
@media only screen and (min-width: 414px) and (max-width: 767px) {
  html {
    font-size: 110px
  }
}

更大屏幕的  100 / x = 375 / 768  x = 204.8
@media only screen and (min-width: 768px) {
  html {
    font-size: 204px
  }
}

那么将.box的font-size就可以用rem为单位了，在标准的375px屏幕下，1rem就是100px,那么16px,就是 0.16rem。

.box {
   font-size: 0.16rem;
}

<div class="box">
  什么是响应式布局？
</div>

在PC端 1000以上的媒体查询写在如下里面：

@media only screen and (min-width:1000px) {
  /* css style*/
}
```

#### 三）图片自适应

1. 对于背景图片来说，css3 有个属性 background-size 可以等比例缩放缩放背景图片。

但是对于小屏幕的移动设备去加载大背景图片的话，有缺点的，最主要的缺点是要更大的带宽，浪费流量。所以我们要想做的更好的话，可以使用媒体查询根据设备的宽度来渲染不同大小的背景图片。

2. 对于页面上的<img/>标签图片的话：

1. 如果只是页面上静态图片的话，不考虑带宽的情况下，可以使用 width=”100%”等比例缩放，如：<img src=”XX.png” width=”100%”/>

1. 如果是商品图或者页面上有多个的话，考虑不浪费不必要的带宽，需要后台根据不同的设备宽度大小来返回不同的 json 数据的图片来给我们前端，之后我们前端使用 JS 动态的渲染出来。

在现代浏览器中（包括 IE7+）中要实现图片随着流动布局相应缩放非常简单，只需要在 css 中加上这么一句代码：

```
  img {
    max-width:100%;
  }
```

含义是：确保图片的最大宽度不会超过浏览器的窗口或其容器可视部分的宽度，所以当窗口或容器的可视部分变窄时，图片的最大宽度值也会相应的变小，图片本身永远不会覆盖容器。

#### 其他的一些方案总结，可以看我之前的总结文章

<a href="https://www.cnblogs.com/tugenhua0707/p/4690986.html">响应性 web 设计实战总结</a>
